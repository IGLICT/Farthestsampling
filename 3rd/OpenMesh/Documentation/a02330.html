<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenMesh: OpenMesh::PropertyManager&lt; PROPTYPE, MeshT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="logo_align.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rwth_vci_rgb.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenMesh
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a02330.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="a02327.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenMesh::PropertyManager&lt; PROPTYPE, MeshT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is intended to manage the lifecycle of properties.  
 <a href="a02330.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00458_source.html">OpenMesh/Core/Utils/PropertyManager.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02334.html">Proxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab669f9c2efb6f9ad356c7c653a8de40c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02330.html#ab669f9c2efb6f9ad356c7c653a8de40c">PropertyManager</a> (MeshT &amp;mesh, const char *propname, bool existing=false)</td></tr>
<tr class="memdesc:ab669f9c2efb6f9ad356c7c653a8de40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ab669f9c2efb6f9ad356c7c653a8de40c">More...</a><br /></td></tr>
<tr class="separator:ab669f9c2efb6f9ad356c7c653a8de40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac1f21a36640158de02c8dffbf81ff0"><td class="memItemLeft" align="right" valign="top"><a id="a1ac1f21a36640158de02c8dffbf81ff0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a02330.html">PropertyManager</a> &amp;rhs)</td></tr>
<tr class="separator:a1ac1f21a36640158de02c8dffbf81ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9535daa19510a51a0b7071ded8120453"><td class="memItemLeft" align="right" valign="top"><a id="a9535daa19510a51a0b7071ded8120453"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValid</b> () const</td></tr>
<tr class="separator:a9535daa19510a51a0b7071ded8120453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61deccf62ce3fdb2b4b9c5f242b78d27"><td class="memItemLeft" align="right" valign="top"><a id="a61deccf62ce3fdb2b4b9c5f242b78d27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator bool</b> () const</td></tr>
<tr class="separator:a61deccf62ce3fdb2b4b9c5f242b78d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc2d0c6b76e06a1679239587edd2e01"><td class="memItemLeft" align="right" valign="top"><a id="acfc2d0c6b76e06a1679239587edd2e01"></a>
const PROPTYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getRawProperty</b> () const</td></tr>
<tr class="separator:acfc2d0c6b76e06a1679239587edd2e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cde31cc2c53d5b6bf691c956b626a4"><td class="memItemLeft" align="right" valign="top"><a id="a44cde31cc2c53d5b6bf691c956b626a4"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getName</b> () const</td></tr>
<tr class="separator:a44cde31cc2c53d5b6bf691c956b626a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d67820fdf8b1d1cfc67549eddd0ce4"><td class="memItemLeft" align="right" valign="top"><a id="a07d67820fdf8b1d1cfc67549eddd0ce4"></a>
MeshT &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getMesh</b> () const</td></tr>
<tr class="separator:a07d67820fdf8b1d1cfc67549eddd0ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9915ccbeea2a78ce68f7ee9432fe10b6"><td class="memItemLeft" align="right" valign="top"><a id="a9915ccbeea2a78ce68f7ee9432fe10b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator Proxy</b> ()</td></tr>
<tr class="separator:a9915ccbeea2a78ce68f7ee9432fe10b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ddf364a994ad862070dfdb8cbdf620"><td class="memItemLeft" align="right" valign="top"><a id="ac6ddf364a994ad862070dfdb8cbdf620"></a>
<a class="el" href="a02334.html">Proxy</a>&#160;</td><td class="memItemRight" valign="bottom"><b>move</b> ()</td></tr>
<tr class="separator:ac6ddf364a994ad862070dfdb8cbdf620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc965e7287262872137602a092da5de"><td class="memItemLeft" align="right" valign="top"><a id="aefc965e7287262872137602a092da5de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PropertyManager</b> (<a class="el" href="a02334.html">Proxy</a> p)</td></tr>
<tr class="separator:aefc965e7287262872137602a092da5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ba8c3df63d76589b170e34ae72972b"><td class="memItemLeft" align="right" valign="top"><a id="a01ba8c3df63d76589b170e34ae72972b"></a>
<a class="el" href="a02330.html">PropertyManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="a02334.html">Proxy</a> p)</td></tr>
<tr class="separator:a01ba8c3df63d76589b170e34ae72972b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cb0e6fd5f3a334140fde962ee0ca6a"><td class="memItemLeft" align="right" valign="top"><a id="a17cb0e6fd5f3a334140fde962ee0ca6a"></a>
<a class="el" href="a02334.html">Proxy</a>&#160;</td><td class="memItemRight" valign="bottom"><b>duplicate</b> (const char *clone_name)</td></tr>
<tr class="separator:a17cb0e6fd5f3a334140fde962ee0ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa388e739951640a7c432b49e5232cb84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02330.html#aa388e739951640a7c432b49e5232cb84">retain</a> (bool doRetain=true)</td></tr>
<tr class="memdesc:aa388e739951640a7c432b49e5232cb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable lifecycle management for this property.  <a href="#aa388e739951640a7c432b49e5232cb84">More...</a><br /></td></tr>
<tr class="separator:aa388e739951640a7c432b49e5232cb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0175f913ec495b7b9699a4a4d0993814"><td class="memItemLeft" align="right" valign="top"><a id="a0175f913ec495b7b9699a4a4d0993814"></a>
PROPTYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02330.html#a0175f913ec495b7b9699a4a4d0993814">operator*</a> ()</td></tr>
<tr class="memdesc:a0175f913ec495b7b9699a4a4d0993814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the encapsulated property. <br /></td></tr>
<tr class="separator:a0175f913ec495b7b9699a4a4d0993814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a879138edcfc4cb6506ef7b83ddc322"><td class="memItemLeft" align="right" valign="top"><a id="a1a879138edcfc4cb6506ef7b83ddc322"></a>
const PROPTYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02330.html#a1a879138edcfc4cb6506ef7b83ddc322">operator*</a> () const</td></tr>
<tr class="memdesc:a1a879138edcfc4cb6506ef7b83ddc322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the encapsulated property. <br /></td></tr>
<tr class="separator:a1a879138edcfc4cb6506ef7b83ddc322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982d39e7eeac8383b3c899b029698496"><td class="memTemplParams" colspan="2">template&lt;typename HandleType &gt; </td></tr>
<tr class="memitem:a982d39e7eeac8383b3c899b029698496"><td class="memTemplItemLeft" align="right" valign="top">PROPTYPE::reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02330.html#a982d39e7eeac8383b3c899b029698496">operator[]</a> (const HandleType &amp;handle)</td></tr>
<tr class="memdesc:a982d39e7eeac8383b3c899b029698496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables convenient access to the encapsulated property.  <a href="#a982d39e7eeac8383b3c899b029698496">More...</a><br /></td></tr>
<tr class="separator:a982d39e7eeac8383b3c899b029698496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e33e1887e065283ea41c868ac51965"><td class="memTemplParams" colspan="2">template&lt;typename HandleType &gt; </td></tr>
<tr class="memitem:ac5e33e1887e065283ea41c868ac51965"><td class="memTemplItemLeft" align="right" valign="top">PROPTYPE::const_reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02330.html#ac5e33e1887e065283ea41c868ac51965">operator[]</a> (const HandleType &amp;handle) const</td></tr>
<tr class="memdesc:ac5e33e1887e065283ea41c868ac51965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables convenient access to the encapsulated property.  <a href="#ac5e33e1887e065283ea41c868ac51965">More...</a><br /></td></tr>
<tr class="separator:ac5e33e1887e065283ea41c868ac51965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7b5c7063fb137ba9552afd4a0ec77f"><td class="memTemplParams" colspan="2">template&lt;typename HandleTypeIterator , typename PROP_VALUE &gt; </td></tr>
<tr class="memitem:a1c7b5c7063fb137ba9552afd4a0ec77f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02330.html#a1c7b5c7063fb137ba9552afd4a0ec77f">set_range</a> (HandleTypeIterator begin, HandleTypeIterator end, const PROP_VALUE &amp;value)</td></tr>
<tr class="memdesc:a1c7b5c7063fb137ba9552afd4a0ec77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniently set the property for an entire range of values.  <a href="#a1c7b5c7063fb137ba9552afd4a0ec77f">More...</a><br /></td></tr>
<tr class="separator:a1c7b5c7063fb137ba9552afd4a0ec77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6397c44399425725499fec75ff110026"><td class="memTemplParams" colspan="2">template&lt;typename HandleTypeIterator , typename PROPTYPE_2 , typename MeshT_2 , typename HandleTypeIterator_2 &gt; </td></tr>
<tr class="memitem:a6397c44399425725499fec75ff110026"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02330.html#a6397c44399425725499fec75ff110026">copy_to</a> (HandleTypeIterator begin, HandleTypeIterator end, <a class="el" href="a02330.html">PropertyManager</a>&lt; PROPTYPE_2, MeshT_2 &gt; &amp;dst_propmanager, HandleTypeIterator_2 dst_begin, HandleTypeIterator_2 dst_end) const</td></tr>
<tr class="memdesc:a6397c44399425725499fec75ff110026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniently transfer the values managed by one property manager onto the values managed by a different property manager.  <a href="#a6397c44399425725499fec75ff110026">More...</a><br /></td></tr>
<tr class="separator:a6397c44399425725499fec75ff110026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b933ad5110c73ce019ea2b8a7e2a9f"><td class="memTemplParams" colspan="2"><a id="a74b933ad5110c73ce019ea2b8a7e2a9f"></a>
template&lt;typename RangeType , typename PROPTYPE_2 , typename MeshT_2 , typename RangeType_2 &gt; </td></tr>
<tr class="memitem:a74b933ad5110c73ce019ea2b8a7e2a9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_to</b> (const RangeType &amp;range, <a class="el" href="a02330.html">PropertyManager</a>&lt; PROPTYPE_2, MeshT_2 &gt; &amp;dst_propmanager, const RangeType_2 &amp;dst_range) const</td></tr>
<tr class="separator:a74b933ad5110c73ce019ea2b8a7e2a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aab5979a603a7f4e2603c5342dda2de30"><td class="memItemLeft" align="right" valign="top"><a id="aab5979a603a7f4e2603c5342dda2de30"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>propertyExists</b> (MeshT &amp;mesh, const char *propname)</td></tr>
<tr class="separator:aab5979a603a7f4e2603c5342dda2de30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcef81e060c6dc8a10a7ed1a7fb01869"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a02334.html">Proxy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02330.html#adcef81e060c6dc8a10a7ed1a7fb01869">createIfNotExists</a> (MeshT &amp;mesh, const char *propname)</td></tr>
<tr class="memdesc:adcef81e060c6dc8a10a7ed1a7fb01869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a property manager for the supplied property and mesh.  <a href="#adcef81e060c6dc8a10a7ed1a7fb01869">More...</a><br /></td></tr>
<tr class="separator:adcef81e060c6dc8a10a7ed1a7fb01869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be8aa3c45827108cfd0a89d1bfe2c28"><td class="memTemplParams" colspan="2">template&lt;typename PROP_VALUE , typename ITERATOR_TYPE &gt; </td></tr>
<tr class="memitem:a6be8aa3c45827108cfd0a89d1bfe2c28"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="a02334.html">Proxy</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02330.html#a6be8aa3c45827108cfd0a89d1bfe2c28">createIfNotExists</a> (MeshT &amp;mesh, const char *propname, const ITERATOR_TYPE &amp;begin, const ITERATOR_TYPE &amp;end, const PROP_VALUE &amp;init_value)</td></tr>
<tr class="memdesc:a6be8aa3c45827108cfd0a89d1bfe2c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="a02330.html#adcef81e060c6dc8a10a7ed1a7fb01869" title="Create a property manager for the supplied property and mesh. ">createIfNotExists()</a> with two parameters except, if the property doesn't exist, it is initialized with the supplied value over the supplied range after creation.  <a href="#a6be8aa3c45827108cfd0a89d1bfe2c28">More...</a><br /></td></tr>
<tr class="separator:a6be8aa3c45827108cfd0a89d1bfe2c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbc2e85d8471cf8915a720aac6e5a7b"><td class="memTemplParams" colspan="2">template&lt;typename RangeType , typename MeshT_2 , typename RangeType_2 &gt; </td></tr>
<tr class="memitem:aadbc2e85d8471cf8915a720aac6e5a7b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02330.html#aadbc2e85d8471cf8915a720aac6e5a7b">copy</a> (const char *prop_name, MeshT &amp;src_mesh, const RangeType &amp;src_range, MeshT_2 &amp;dst_mesh, const RangeType_2 &amp;dst_range)</td></tr>
<tr class="memdesc:aadbc2e85d8471cf8915a720aac6e5a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the values of a property from a source range to a target range.  <a href="#aadbc2e85d8471cf8915a720aac6e5a7b">More...</a><br /></td></tr>
<tr class="separator:aadbc2e85d8471cf8915a720aac6e5a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a6a48e0a7e2115953158298617626bd87"><td class="memTemplParams" colspan="2">template&lt;typename PROPTYPE , typename MeshT &gt; </td></tr>
<tr class="memitem:a6a48e0a7e2115953158298617626bd87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02330.html">PropertyManager</a>&lt; PROPTYPE, MeshT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02330.html#a6a48e0a7e2115953158298617626bd87">makePropertyManagerFromNew</a> (MeshT &amp;mesh, const char *propname)</td></tr>
<tr class="separator:a6a48e0a7e2115953158298617626bd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867447f5f0bef7f7e1566c0f1dfa4e51"><td class="memTemplParams" colspan="2">template&lt;typename PROPTYPE , typename MeshT &gt; </td></tr>
<tr class="memitem:a867447f5f0bef7f7e1566c0f1dfa4e51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02330.html">PropertyManager</a>&lt; PROPTYPE, MeshT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02330.html#a867447f5f0bef7f7e1566c0f1dfa4e51">makePropertyManagerFromExisting</a> (MeshT &amp;mesh, const char *propname)</td></tr>
<tr class="separator:a867447f5f0bef7f7e1566c0f1dfa4e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade542fc7505f5988782515b8d9873408"><td class="memTemplParams" colspan="2">template&lt;typename PROPTYPE , typename MeshT &gt; </td></tr>
<tr class="memitem:ade542fc7505f5988782515b8d9873408"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02330.html">PropertyManager</a>&lt; PROPTYPE, MeshT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02330.html#ade542fc7505f5988782515b8d9873408">makePropertyManagerFromExistingOrNew</a> (MeshT &amp;mesh, const char *propname)</td></tr>
<tr class="separator:ade542fc7505f5988782515b8d9873408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28dc870789c604c3c49a1d21d6ed86f"><td class="memTemplParams" colspan="2">template&lt;typename PROPTYPE , typename MeshT , typename ITERATOR_TYPE , typename PROP_VALUE &gt; </td></tr>
<tr class="memitem:ad28dc870789c604c3c49a1d21d6ed86f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02330.html">PropertyManager</a>&lt; PROPTYPE, MeshT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02330.html#ad28dc870789c604c3c49a1d21d6ed86f">makePropertyManagerFromExistingOrNew</a> (MeshT &amp;mesh, const char *propname, const ITERATOR_TYPE &amp;begin, const ITERATOR_TYPE &amp;end, const PROP_VALUE &amp;init_value)</td></tr>
<tr class="separator:ad28dc870789c604c3c49a1d21d6ed86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4726501b7561ddbbb734e1c9dbdb53e3"><td class="memTemplParams" colspan="2">template&lt;typename PROPTYPE , typename MeshT , typename ITERATOR_RANGE , typename PROP_VALUE &gt; </td></tr>
<tr class="memitem:a4726501b7561ddbbb734e1c9dbdb53e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02330.html">PropertyManager</a>&lt; PROPTYPE, MeshT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02330.html#a4726501b7561ddbbb734e1c9dbdb53e3">makePropertyManagerFromExistingOrNew</a> (MeshT &amp;mesh, const char *propname, const ITERATOR_RANGE &amp;range, const PROP_VALUE &amp;init_value)</td></tr>
<tr class="separator:a4726501b7561ddbbb734e1c9dbdb53e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename PROPTYPE, typename MeshT&gt;<br />
class OpenMesh::PropertyManager&lt; PROPTYPE, MeshT &gt;</h3>

<p>This class is intended to manage the lifecycle of properties. </p>
<p>It also defines convenience operators to access the encapsulated property's value.</p>
<p>For C++11, it is recommended to use the factory functions makePropertyManagerFromNew, makePropertyManagerFromExisting, makePropertyManagerFromExistingOrNew to construct a <a class="el" href="a02330.html" title="This class is intended to manage the lifecycle of properties. ">PropertyManager</a>, e.g.</p>
<div class="fragment"><div class="line">TriMesh mesh;</div><div class="line"><span class="keyword">auto</span> visited = makePropertyManagerFromNew&lt;VPropHandleT&lt;bool&gt;&gt;(mesh, <span class="stringliteral">&quot;visited.plugin-example.i8.informatik.rwth-aachen.de&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> vh : mesh.vertices()) {</div><div class="line">    <span class="keywordflow">if</span> (!visited[vh]) {</div><div class="line">        visitComponent(mesh, vh, visited);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>For C++98, it is usually more convenient to use the constructor explicitly, i.e.</p>
<div class="fragment"><div class="line">TriMesh mesh;</div><div class="line">PropertyManager&lt;VPropHandleT&lt;bool&gt;, TriMesh&gt; visited(mesh, <span class="stringliteral">&quot;visited.plugin-example.i8.informatik.rwth-aachen.de&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (TriMesh::VertexIter vh_it = mesh.begin(); ... ; ...) {</div><div class="line">    <span class="keywordflow">if</span> (!visited[*vh_it]) {</div><div class="line">        visitComponent(mesh, *vh_it, visited);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab669f9c2efb6f9ad356c7c653a8de40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab669f9c2efb6f9ad356c7c653a8de40c">&#9670;&nbsp;</a></span>PropertyManager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROPTYPE, typename MeshT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02330.html">OpenMesh::PropertyManager</a>&lt; PROPTYPE, MeshT &gt;::<a class="el" href="a02330.html">PropertyManager</a> </td>
          <td>(</td>
          <td class="paramtype">MeshT &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>existing</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Throws an <code>std::runtime_error</code> if <code>existing</code> is true and no property named <code>propname</code> of the appropriate property type exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh on which to create the property. </td></tr>
    <tr><td class="paramname">propname</td><td>The name of the property. </td></tr>
    <tr><td class="paramname">existing</td><td>If false, a new property is created and its lifecycle is managed (i.e. the property is deleted upon destruction of the <a class="el" href="a02330.html" title="This class is intended to manage the lifecycle of properties. ">PropertyManager</a> instance). If true, the instance merely acts as a convenience wrapper around an existing property with no lifecycle management whatsoever.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a02330.html#adcef81e060c6dc8a10a7ed1a7fb01869" title="Create a property manager for the supplied property and mesh. ">PropertyManager::createIfNotExists</a>, <a class="el" href="a02330.html#a6a48e0a7e2115953158298617626bd87">makePropertyManagerFromNew</a>, <a class="el" href="a02330.html#a867447f5f0bef7f7e1566c0f1dfa4e51">makePropertyManagerFromExisting</a>, <a class="el" href="a02330.html#ade542fc7505f5988782515b8d9873408">makePropertyManagerFromExistingOrNew</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aadbc2e85d8471cf8915a720aac6e5a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbc2e85d8471cf8915a720aac6e5a7b">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROPTYPE, typename MeshT&gt; </div>
<div class="memtemplate">
template&lt;typename RangeType , typename MeshT_2 , typename RangeType_2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="a02330.html">OpenMesh::PropertyManager</a>&lt; PROPTYPE, MeshT &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prop_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshT &amp;&#160;</td>
          <td class="paramname"><em>src_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeType &amp;&#160;</td>
          <td class="paramname"><em>src_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshT_2 &amp;&#160;</td>
          <td class="paramname"><em>dst_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeType_2 &amp;&#160;</td>
          <td class="paramname"><em>dst_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the values of a property from a source range to a target range. </p>
<p>The source range must not be smaller than the target range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prop_name</td><td>Name of the property to copy. Must exist on the source mesh. Will be created on the target mesh if it doesn't exist.</td></tr>
    <tr><td class="paramname">src_mesh</td><td>Source mesh from which to copy. </td></tr>
    <tr><td class="paramname">src_range</td><td>Source range which to copy. Must not be smaller than dst_range. </td></tr>
    <tr><td class="paramname">dst_mesh</td><td>Destination mesh on which to copy. </td></tr>
    <tr><td class="paramname">dst_range</td><td>Destination range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6397c44399425725499fec75ff110026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6397c44399425725499fec75ff110026">&#9670;&nbsp;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROPTYPE, typename MeshT&gt; </div>
<div class="memtemplate">
template&lt;typename HandleTypeIterator , typename PROPTYPE_2 , typename MeshT_2 , typename HandleTypeIterator_2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a02330.html">OpenMesh::PropertyManager</a>&lt; PROPTYPE, MeshT &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype">HandleTypeIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandleTypeIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02330.html">PropertyManager</a>&lt; PROPTYPE_2, MeshT_2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst_propmanager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandleTypeIterator_2&#160;</td>
          <td class="paramname"><em>dst_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandleTypeIterator_2&#160;</td>
          <td class="paramname"><em>dst_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conveniently transfer the values managed by one property manager onto the values managed by a different property manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Start iterator. Needs to dereference to HandleType. Will be used with this property manager. </td></tr>
    <tr><td class="paramname">end</td><td>End iterator. (Exclusive.) Will be used with this property manager. </td></tr>
    <tr><td class="paramname">dst_propmanager</td><td>The destination property manager. </td></tr>
    <tr><td class="paramname">dst_begin</td><td>Start iterator. Needs to dereference to the HandleType of dst_propmanager. Will be used with dst_propmanager. </td></tr>
    <tr><td class="paramname">dst_end</td><td>End iterator. (Exclusive.) Will be used with dst_propmanager. Used to double check the bounds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcef81e060c6dc8a10a7ed1a7fb01869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcef81e060c6dc8a10a7ed1a7fb01869">&#9670;&nbsp;</a></span>createIfNotExists() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROPTYPE, typename MeshT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a02334.html">Proxy</a> <a class="el" href="a02330.html">OpenMesh::PropertyManager</a>&lt; PROPTYPE, MeshT &gt;::createIfNotExists </td>
          <td>(</td>
          <td class="paramtype">MeshT &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a property manager for the supplied property and mesh. </p>
<p>If the property doesn't exist, it is created. In any case, lifecycle management is disabled.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a02330.html#ade542fc7505f5988782515b8d9873408">makePropertyManagerFromExistingOrNew</a> </dd></dl>

</div>
</div>
<a id="a6be8aa3c45827108cfd0a89d1bfe2c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be8aa3c45827108cfd0a89d1bfe2c28">&#9670;&nbsp;</a></span>createIfNotExists() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROPTYPE, typename MeshT&gt; </div>
<div class="memtemplate">
template&lt;typename PROP_VALUE , typename ITERATOR_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a02334.html">Proxy</a> <a class="el" href="a02330.html">OpenMesh::PropertyManager</a>&lt; PROPTYPE, MeshT &gt;::createIfNotExists </td>
          <td>(</td>
          <td class="paramtype">MeshT &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ITERATOR_TYPE &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ITERATOR_TYPE &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PROP_VALUE &amp;&#160;</td>
          <td class="paramname"><em>init_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="a02330.html#adcef81e060c6dc8a10a7ed1a7fb01869" title="Create a property manager for the supplied property and mesh. ">createIfNotExists()</a> with two parameters except, if the property doesn't exist, it is initialized with the supplied value over the supplied range after creation. </p>
<p>If the property already exists, this method has the exact same effect as the two parameter version. Lifecycle management is disabled in any case.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a02330.html#ade542fc7505f5988782515b8d9873408">makePropertyManagerFromExistingOrNew</a> </dd></dl>

</div>
</div>
<a id="a982d39e7eeac8383b3c899b029698496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982d39e7eeac8383b3c899b029698496">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROPTYPE, typename MeshT&gt; </div>
<div class="memtemplate">
template&lt;typename HandleType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PROPTYPE::reference <a class="el" href="a02330.html">OpenMesh::PropertyManager</a>&lt; PROPTYPE, MeshT &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const HandleType &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables convenient access to the encapsulated property. </p>
<p>For a usage example see this class' documentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle of the appropriate handle type. (I.e. <code><a class="el" href="a02158.html" title="Handle for a vertex entity. ">VertexHandle</a></code> for <code><a class="el" href="a02306.html" title="Handle representing a vertex property. ">VPropHandleT</a></code>, etc.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5e33e1887e065283ea41c868ac51965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e33e1887e065283ea41c868ac51965">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROPTYPE, typename MeshT&gt; </div>
<div class="memtemplate">
template&lt;typename HandleType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PROPTYPE::const_reference <a class="el" href="a02330.html">OpenMesh::PropertyManager</a>&lt; PROPTYPE, MeshT &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const HandleType &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables convenient access to the encapsulated property. </p>
<p>For a usage example see this class' documentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle of the appropriate handle type. (I.e. <code><a class="el" href="a02158.html" title="Handle for a vertex entity. ">VertexHandle</a></code> for <code><a class="el" href="a02306.html" title="Handle representing a vertex property. ">VPropHandleT</a></code>, etc.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa388e739951640a7c432b49e5232cb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa388e739951640a7c432b49e5232cb84">&#9670;&nbsp;</a></span>retain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROPTYPE, typename MeshT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a02330.html">OpenMesh::PropertyManager</a>&lt; PROPTYPE, MeshT &gt;::retain </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doRetain</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable lifecycle management for this property. </p>
<p>If this method is called, the encapsulated property will not be deleted upon destruction of the <a class="el" href="a02330.html" title="This class is intended to manage the lifecycle of properties. ">PropertyManager</a> instance. </p>

</div>
</div>
<a id="a1c7b5c7063fb137ba9552afd4a0ec77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7b5c7063fb137ba9552afd4a0ec77f">&#9670;&nbsp;</a></span>set_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROPTYPE, typename MeshT&gt; </div>
<div class="memtemplate">
template&lt;typename HandleTypeIterator , typename PROP_VALUE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a02330.html">OpenMesh::PropertyManager</a>&lt; PROPTYPE, MeshT &gt;::set_range </td>
          <td>(</td>
          <td class="paramtype">HandleTypeIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandleTypeIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PROP_VALUE &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conveniently set the property for an entire range of values. </p>
<p>Examples: </p><div class="fragment"><div class="line">MeshT mesh;</div><div class="line">PropertyManager&lt;VPropHandleT&lt;double&gt;, MeshT&gt; distance(</div><div class="line">    mesh, <span class="stringliteral">&quot;distance.plugin-example.i8.informatik.rwth-aachen.de&quot;</span>);</div><div class="line">distance.set_range(</div><div class="line">    mesh.vertices_begin(), mesh.vertices_end(),</div><div class="line">    std::numeric_limits&lt;double&gt;::infinity());</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">MeshT::VertexHandle vh;</div><div class="line">distance.set_range(</div><div class="line">    mesh.vv_begin(vh), mesh.vv_end(vh),</div><div class="line">    std::numeric_limits&lt;double&gt;::infinity());</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Start iterator. Needs to dereference to HandleType. </td></tr>
    <tr><td class="paramname">end</td><td>End iterator. (Exclusive.) </td></tr>
    <tr><td class="paramname">value</td><td>The value the range will be set to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a867447f5f0bef7f7e1566c0f1dfa4e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867447f5f0bef7f7e1566c0f1dfa4e51">&#9670;&nbsp;</a></span>makePropertyManagerFromExisting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROPTYPE , typename MeshT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02330.html">PropertyManager</a>&lt; PROPTYPE, MeshT &gt; makePropertyManagerFromExisting </td>
          <td>(</td>
          <td class="paramtype">MeshT &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a non-owning wrapper for an existing mesh property (no lifecycle management).</p>
<p>Intended for convenient access.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Property with the name <code>propname</code> of matching type exists. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if no property with the name <code>propname</code> of matching type exists. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade542fc7505f5988782515b8d9873408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade542fc7505f5988782515b8d9873408">&#9670;&nbsp;</a></span>makePropertyManagerFromExistingOrNew() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROPTYPE , typename MeshT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02330.html">PropertyManager</a>&lt; PROPTYPE, MeshT &gt; makePropertyManagerFromExistingOrNew </td>
          <td>(</td>
          <td class="paramtype">MeshT &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a non-owning wrapper for a mesh property (no lifecycle management). If the given property does not exist, it is created.</p>
<p>Intended for creating or accessing persistent properties. </p>

</div>
</div>
<a id="ad28dc870789c604c3c49a1d21d6ed86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28dc870789c604c3c49a1d21d6ed86f">&#9670;&nbsp;</a></span>makePropertyManagerFromExistingOrNew() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROPTYPE , typename MeshT , typename ITERATOR_TYPE , typename PROP_VALUE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02330.html">PropertyManager</a>&lt; PROPTYPE, MeshT &gt; makePropertyManagerFromExistingOrNew </td>
          <td>(</td>
          <td class="paramtype">MeshT &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ITERATOR_TYPE &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ITERATOR_TYPE &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PROP_VALUE &amp;&#160;</td>
          <td class="paramname"><em>init_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like the two parameter version of <a class="el" href="a02330.html#ade542fc7505f5988782515b8d9873408">makePropertyManagerFromExistingOrNew()</a> except it initializes the property with the specified value over the specified range if it needs to be created. If the property already exists, this function has the exact same effect as the two parameter version.</p>
<p>Creates a non-owning wrapper for a mesh property (no lifecycle management). If the given property does not exist, it is created.</p>
<p>Intended for creating or accessing persistent properties. </p>

</div>
</div>
<a id="a4726501b7561ddbbb734e1c9dbdb53e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4726501b7561ddbbb734e1c9dbdb53e3">&#9670;&nbsp;</a></span>makePropertyManagerFromExistingOrNew() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROPTYPE , typename MeshT , typename ITERATOR_RANGE , typename PROP_VALUE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02330.html">PropertyManager</a>&lt; PROPTYPE, MeshT &gt; makePropertyManagerFromExistingOrNew </td>
          <td>(</td>
          <td class="paramtype">MeshT &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ITERATOR_RANGE &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PROP_VALUE &amp;&#160;</td>
          <td class="paramname"><em>init_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like the two parameter version of <a class="el" href="a02330.html#ade542fc7505f5988782515b8d9873408">makePropertyManagerFromExistingOrNew()</a> except it initializes the property with the specified value over the specified range if it needs to be created. If the property already exists, this function has the exact same effect as the two parameter version.</p>
<p>Creates a non-owning wrapper for a mesh property (no lifecycle management). If the given property does not exist, it is created.</p>
<p>Intended for creating or accessing persistent properties. </p>

</div>
</div>
<a id="a6a48e0a7e2115953158298617626bd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a48e0a7e2115953158298617626bd87">&#9670;&nbsp;</a></span>makePropertyManagerFromNew()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROPTYPE , typename MeshT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02330.html">PropertyManager</a>&lt; PROPTYPE, MeshT &gt; makePropertyManagerFromNew </td>
          <td>(</td>
          <td class="paramtype">MeshT &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new property whose lifecycle is managed by the returned <a class="el" href="a02330.html" title="This class is intended to manage the lifecycle of properties. ">PropertyManager</a>.</p>
<p>Intended for temporary properties. Shadows any existsing properties of matching name and type. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>OpenMesh/Core/Utils/<a class="el" href="a00458_source.html">PropertyManager.hh</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
